<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN"
        "http://www.w3.org/TR/html4/strict.dtd">

<html lang='en'>
<head>
<meta http-equiv="content-type" content="text/html; charset=utf-8" >
<title>tharsis.prof.chunkyeventlist - Tharsis.prof 0.5 API documentation</title>
<link rel="stylesheet" type="text/css" href="css/style.css">
</head>

<body><div id="top">
<div id="header">
<a id="main-heading" href="index.html">Tharsis.prof 0.5 API documentation</a>
</div>
</div>

<div id="navigation">
<div class="navblock">
<div id="toctop">
<ul><li><a href="http://code.dlang.org">More D libraries</a></li>
</ul>
</div>
</div>
<div class="navblock">
<ul><li><a href="index.html">Main page</a></li>
<li><a href="tharsis.prof.chunkyeventlist.html">tharsis.prof.chunkyeventlist</a></li>
<li><a href="tharsis.prof.csv.html">tharsis.prof.csv</a></li>
<li><a href="tharsis.prof.despikersender.html">tharsis.prof.despikersender</a></li>
<li><a href="tharsis.prof.event.html">tharsis.prof.event</a></li>
<li><a href="tharsis.prof.profiler.html">tharsis.prof.profiler</a></li>
<li><a href="tharsis.prof.ranges.html">tharsis.prof.ranges</a></li>
</ul>
</div>
</div>

<div id="content">
<h1>tharsis.prof.chunkyeventlist</h1>
<!-- Generated by Ddoc from tharsis/prof/chunkyeventlist.d -->
<p>A 'chunky' event list that supports real-time adding of profiling data and related
 ranges/generators.</p>

<dl><dt class="d_decl"><a name="ChunkyEventList"></a>struct <a name="ChunkyEventList"></a><span class="ddoc_psymbol">ChunkyEventList</span>;
</dt>
<dd><p>A list of events providing range 'slices', using chunks of profiling data for storage.
</p>
<p>Useful for real-time profiling (used by Despiker); can add new chunks of profile data
 in real time and create ranges to generate events in specified time or chunk slices
 without processing the preceding chunks.</p>

<dl><dt class="d_decl"><a name="ChunkyEventList.Chunk"></a>struct <a name="Chunk"></a><span class="ddoc_psymbol">Chunk</span>;
</dt>
<dd><p>A single chunk of profiling data.
</p>
<p>Public so the user can allocate chunks for ChunkyEventList storage.</p>

</dd>
<dt class="d_decl"><a name="ChunkyEventList.Generator"></a>struct <a name="Generator"></a><span class="ddoc_psymbol">Generator</span>;
</dt>
<dd><p>Generates events from the event list as chunks are added.
</p>
<p>Range is not useful here, since it would either have to be 'empty' after consuming
 events from existing chunks even though more chunks may be added, or block in
 popFront(), which would only make it usable from separate threads/fibers.</p>

<dl><dt class="d_decl"><a name="ChunkyEventList.Generator.GeneratedEvent"></a>struct <a name="GeneratedEvent"></a><span class="ddoc_psymbol">GeneratedEvent</span>;
</dt>
<dd><p>A profile event generated by Generator.
</p>
<p>This is a tharsis.prof.Event with some extra data to generate SliceExtents for
 zones generated from GeneratedEvents.</p>

<dl><dt class="d_decl"><a name="ChunkyEventList.Generator.GeneratedEvent.event"></a>Event <a name="event"></a><span class="ddoc_psymbol">event</span>;
</dt>
<dd><p>Profiling <a name="event"></a><span class="ddoc_psymbol">event</span> itself.</p>

</dd>
</dl>
</dd>
<dt class="d_decl"><a name="ChunkyEventList.Generator.this"></a>pure nothrow @nogc @safe this(const(ChunkyEventList)* <b>events</b>);
</dt>
<dd><p>Construct a Generator.
</p>
<b>Parameters:</b><div class="pbr"><table class=parms><tr><td valign=top>const(ChunkyEventList)* <b>events</b></td>
<td valign=top>Chunky event list to generate <b>events</b> from.</td></tr>
</table></div>

</dd>
<dt class="d_decl"><a name="ChunkyEventList.Generator.generate"></a>pure nothrow @nogc @safe bool <a name="generate"></a><span class="ddoc_psymbol">generate</span>(out GeneratedEvent <b>event</b>);
</dt>
<dd><p>Try to <a name="generate"></a><span class="ddoc_psymbol">generate</span> the next <b>event</b>.
</p>
<b>Parameters:</b><div class="pbr"><table class=parms><tr><td valign=top>GeneratedEvent <b>event</b></td>
<td valign=top>The <b>event</b> will be written here, if generated.</td></tr>
</table></div>
<b>Returns:</b><div class="pbr"><b>true</b> if an <b>event</b> was generated, <b>false</b> otherwise (all chunks that
          have been added to the <b>event</b> list so far have been spent).</div>

</dd>
</dl>
</dd>
<dt class="d_decl"><a name="ChunkyEventList.Slice"></a>struct <a name="Slice"></a><span class="ddoc_psymbol">Slice</span>;
</dt>
<dd><p>A 'slice' of events in the chunky event list.
</p>
<p>Produced by ChunkyEventList.slice() from SliceExtents. SliceExtents are currently
 generated only by ChunkyZoneGenerator, which creates exact slices for generated
 zones.
<br>

 Unlike TimeSlice, which is a slice of all events in specified time, <a name="Slice"></a><span class="ddoc_psymbol">Slice</span> is more
 precise; it starts and ends at specific events (TimeSlice includes any events in
 specified time, even if multiple events have occured the same time, which can cause
 issues with zones when a time slice for a zone includes the zone end event for the
 previous zone, which may have ended in the same hectonanosecond as the new zone).</p>

<dl><dt class="d_decl"><a name="ChunkyEventList.Slice.front"></a>const pure nothrow @nogc @safe Event <a name="front"></a><span class="ddoc_psymbol">front</span>();
</dt>
<dd><p>Get the event on <a name="front"></a><span class="ddoc_psymbol">front</span> of the slice.</p>

</dd>
<dt class="d_decl"><a name="ChunkyEventList.Slice.popFront"></a>pure nothrow @nogc @safe void <a name="popFront"></a><span class="ddoc_psymbol">popFront</span>();
</dt>
<dd><p>Move to the next event.</p>

</dd>
<dt class="d_decl"><a name="ChunkyEventList.Slice.empty"></a>const pure nothrow @nogc @safe bool <a name="empty"></a><span class="ddoc_psymbol">empty</span>();
</dt>
<dd><p>Is the slice <a name="empty"></a><span class="ddoc_psymbol">empty</span>?</p>

</dd>
<dt class="d_decl"><a name="ChunkyEventList.Slice.save"></a>const pure nothrow @nogc @property @safe Slice <a name="save"></a><span class="ddoc_psymbol">save</span>();
</dt>
<dd><p>Get a copy of the slice in its current state.</p>

</dd>
</dl>
</dd>
<dt class="d_decl"><a name="ChunkyEventList.TimeSlice"></a>struct <a name="TimeSlice"></a><span class="ddoc_psymbol">TimeSlice</span>;
</dt>
<dd><p>A 'slice' of events based on start end end time.
</p>
<p>Produced by ChunkyEventList.timeSlice().
<br>

 <a name="TimeSlice"></a><span class="ddoc_psymbol">TimeSlice</span> is useful to get events in specified time extents but may be useless
 for zone generation as it may contain zone end events for zones that started before
 the slice. Even if a time slice starting exactly at a zone start time is used, a
 preceding zone may have ended in the same hectonanosecond.</p>

<dl><dt class="d_decl"><a name="ChunkyEventList.TimeSlice.front"></a>const pure nothrow @nogc @safe Event <a name="front"></a><span class="ddoc_psymbol">front</span>();
</dt>
<dd><p>Get the event on <a name="front"></a><span class="ddoc_psymbol">front</span> of the slice.</p>

</dd>
<dt class="d_decl"><a name="ChunkyEventList.TimeSlice.popFront"></a>pure nothrow @nogc @safe void <a name="popFront"></a><span class="ddoc_psymbol">popFront</span>();
</dt>
<dd><p>Move to the next event.</p>

</dd>
<dt class="d_decl"><a name="ChunkyEventList.TimeSlice.empty"></a>const pure nothrow @nogc @safe bool <a name="empty"></a><span class="ddoc_psymbol">empty</span>();
</dt>
<dd><p>Is the slice <a name="empty"></a><span class="ddoc_psymbol">empty</span>?</p>

</dd>
<dt class="d_decl"><a name="ChunkyEventList.TimeSlice.save"></a>const pure nothrow @nogc @property @safe TimeSlice <a name="save"></a><span class="ddoc_psymbol">save</span>();
</dt>
<dd><p>Get a copy of the range in its current state.</p>

</dd>
</dl>
</dd>
<dt class="d_decl"><a name="ChunkyEventList.SliceExtents"></a>struct <a name="SliceExtents"></a><span class="ddoc_psymbol">SliceExtents</span>;
</dt>
<dd><p>Extents of a Slice.</p>

</dd>
<dt class="d_decl"><a name="ChunkyEventList.this"></a>pure nothrow @nogc @safe this(Chunk[] <b>chunkStorage</b>);
</dt>
<dd><p>Construct a ChunkyEventList.
</p>
<b>Parameters:</b><div class="pbr"><table class=parms><tr><td valign=top>Chunk[] <b>chunkStorage</b></td>
<td valign=top>Space allocated for profile data chunks (not chunk data itself).
                outOfSpace() must be called before adding chunks to determine if
                this space has been spent, and provideStorage() must be called
                to allocate more chunks after running out of space. ChunkyEventList
                never allocates by itself.</td></tr>
</table></div>

</dd>
<dt class="d_decl"><a name="ChunkyEventList.outOfSpace"></a>const pure nothrow @nogc @safe bool <a name="outOfSpace"></a><span class="ddoc_psymbol">outOfSpace</span>();
</dt>
<dd><p>Is the ChunkyEventList out of space?
</p>
<p>If <b>true</b>, more chunk storage must be provided by calling provideStorage().</p>

</dd>
<dt class="d_decl"><a name="ChunkyEventList.provideStorage"></a>pure nothrow @nogc @safe void <a name="provideStorage"></a><span class="ddoc_psymbol">provideStorage</span>(Chunk[] <b>storage</b>);
</dt>
<dd><p>Provide more space to store chunks (not chunk data itself).
</p>
<p>Must be called when outOfSpace() returns <b>true</b>. Must provide more space than the
 preceding <a name="provideStorage"></a><span class="ddoc_psymbol">provideStorage</span>() or constructor call.</p>

</dd>
<dt class="d_decl"><a name="ChunkyEventList.generator"></a>const pure nothrow @nogc @safe Generator <a name="generator"></a><span class="ddoc_psymbol">generator</span>();
</dt>
<dd><p>Get a <a name="generator"></a><span class="ddoc_psymbol">generator</span> to produce profiling events from the list over time as chunks are added.</p>

</dd>
<dt class="d_decl"><a name="ChunkyEventList.addChunk"></a>pure nothrow @nogc @safe bool <a name="addChunk"></a><span class="ddoc_psymbol">addChunk</span>(immutable(ubyte)[] <b>data</b>);
</dt>
<dd><p>Add a new chunk of profile <b>data</b>.
</p>
<b>Parameters:</b><div class="pbr"><table class=parms><tr><td valign=top>immutable(ubyte)[] <b>data</b></td>
<td valign=top>Chunk of <b>data</b> to add. Note that the first event in the chunk must have
        higher time value for the chunk to be added (<b>false</b> will be returned on
        error). This can be ensured by emitting a checkpoint event with the Profiler
        that produces the chunk before any other events in the chunk. Also note that
        <b>data</b> <b>must not</b> be deallocated for as long as the ChunkyEventList exists;
        the ChunkyEventList will use <b>data</b> directly instead of creating a copy.</td></tr>
</table></div>
<b>Returns:</b><div class="pbr"><b>true</b> on success, <b>false</b> if the first event in the chunk didn't occur in
          time after the last event already in the list.</div>

</dd>
<dt class="d_decl"><a name="ChunkyEventList.slice"></a>const pure nothrow @nogc @safe Slice <a name="slice"></a><span class="ddoc_psymbol">slice</span>(SliceExtents <a name="slice"></a><span class="ddoc_psymbol">slice</span>);
</dt>
<dd><p>Get an exact <a name="slice"></a><span class="ddoc_psymbol">slice</span> of the ChunkyEventList as described by a SliceExtents instance.
</p>
<p>SliceExtents is currently only generated by the ChunkyZoneGenerator to allow
 getting exact slices containing only the events in any single zone, as opposed to
 all events that occured at the time of that zone (e.g. an end of a preceding zone
 that occured in the same hectonanosecond a new zone started in).</p>

</dd>
<dt class="d_decl"><a name="ChunkyEventList.timeSlice"></a>const pure nothrow @nogc @safe TimeSlice <a name="timeSlice"></a><span class="ddoc_psymbol">timeSlice</span>(ulong <b>start</b>, ulong <b>end</b>);
</dt>
<dd><p>Get a slice of the ChunkyEventList containing events in specified time range.
</p>
<b>Parameters:</b><div class="pbr"><table class=parms><tr><td valign=top>ulong <b>start</b></td>
<td valign=top>Start of the time slice. Events occuring at this time will be included.</td></tr>
<tr><td valign=top>ulong <b>end</b></td>
<td valign=top>End of the time slice. Events occuring at this time will <span class="d_inlinecode">not</span> be included.</td></tr>
</table></div>

</dd>
</dl>
</dd>
<dt class="d_decl"><a name="ChunkyEventGenerator"></a>alias <a name="ChunkyEventGenerator"></a><span class="ddoc_psymbol">ChunkyEventGenerator</span> = ChunkyEventList.Generator;
</dt>
<dd><p>Readability alias.</p>

</dd>
<dt class="d_decl"><a name="ChunkyEventSlice"></a>alias <a name="ChunkyEventSlice"></a><span class="ddoc_psymbol">ChunkyEventSlice</span> = ChunkyEventList.Slice;
</dt>
<dd><p>Readability alias.</p>

</dd>
<dt class="d_decl"><a name="ChunkyZoneGenerator"></a>struct <a name="ChunkyZoneGenerator"></a><span class="ddoc_psymbol">ChunkyZoneGenerator</span>;
</dt>
<dd><p>Generates zones from a ChunkyEventList as chunks are added.
</p>
<p>Range is not useful here, since it would either have to be 'empty' after consuming
 zones from existing chunks even though more chunks may be added, or block in
 popFront(), which would only make it usable from separate threads/fibers.</p>

<dl><dt class="d_decl"><a name="ChunkyZoneGenerator.GeneratedZoneData"></a>struct <a name="GeneratedZoneData"></a><span class="ddoc_psymbol">GeneratedZoneData</span>;
</dt>
<dd><p>ZoneData extended with ChunkyEventList slice extents to regenerate events in the zone.</p>

<dl><dt class="d_decl"><a name="ChunkyZoneGenerator.GeneratedZoneData.extents"></a>ChunkyEventList.SliceExtents <a name="extents"></a><span class="ddoc_psymbol">extents</span>;
</dt>
<dd><p>ChunkyEventList <a name="extents"></a><span class="ddoc_psymbol">extents</span> of all events used to produce this zone.
</p>
<p>Allows to slice the ChunkyEventList to reproduce the zone and its children.</p>

</dd>
<dt class="d_decl"><a name="ChunkyZoneGenerator.GeneratedZoneData.zoneData"></a>ZoneData <a name="zoneData"></a><span class="ddoc_psymbol">zoneData</span>;
</dt>
<dd><p>The zone data itself.</p>

</dd>
</dl>
</dd>
<dt class="d_decl"><a name="ChunkyZoneGenerator.this"></a>pure nothrow @nogc @safe this(ChunkyEventGenerator <b>events</b>);
</dt>
<dd><p>Construct a ChunkyZoneRange.
</p>
<b>Parameters:</b><div class="pbr"><table class=parms><tr><td valign=top>eventList</td>
<td valign=top>Chunky event generator (returned by ChunkyEventList.generator()) to
             produce <b>events</b> to generate zones from.</td></tr>
</table></div>

</dd>
<dt class="d_decl"><a name="ChunkyZoneGenerator.generate"></a>pure nothrow @nogc @safe bool <a name="generate"></a><span class="ddoc_psymbol">generate</span>(out GeneratedZoneData <b>zone</b>);
</dt>
<dd><p>Try to <a name="generate"></a><span class="ddoc_psymbol">generate</span> the next <b>zone</b>.
</p>
<b>Parameters:</b><div class="pbr"><table class=parms><tr><td valign=top>GeneratedZoneData <b>zone</b></td>
<td valign=top>The <b>zone</b> will be written here, if generated.</td></tr>
</table></div>
<b>Returns:</b><div class="pbr"><b>true</b> if an <b>zone</b> was generated, <b>false</b> otherwise (all chunks that have been
          added to the event list so far have been spent).</div>

</dd>
</dl>
</dd>
</dl>

</div>

<div id="copyright">
Copyright &copy; Ferdinand Majerech 2014 |
Page generated by AutoDDoc and <a href="http://www.digitalmars.com/d/2.0/ddoc.html">Ddoc</a>.
</div>

</body>
</html>

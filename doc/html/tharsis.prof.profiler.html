<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN"
        "http://www.w3.org/TR/html4/strict.dtd">

<html lang='en'>
<head>
<meta http-equiv="content-type" content="text/html; charset=utf-8" >
<title>tharsis.prof.profiler - Tharsis.prof 0.5 API documentation</title>
<link rel="stylesheet" type="text/css" href="css/style.css">
</head>

<body><div id="top">
<div id="header">
<a id="main-heading" href="index.html">Tharsis.prof 0.5 API documentation</a>
</div>
</div>

<div id="navigation">
<div class="navblock">
<div id="toctop">
<ul><li><a href="http://code.dlang.org">More D libraries</a></li>
</ul>
</div>
</div>
<div class="navblock">
<ul><li><a href="index.html">Main page</a></li>
<li><a href="tharsis.prof.chunkyeventlist.html">tharsis.prof.chunkyeventlist</a></li>
<li><a href="tharsis.prof.csv.html">tharsis.prof.csv</a></li>
<li><a href="tharsis.prof.despikersender.html">tharsis.prof.despikersender</a></li>
<li><a href="tharsis.prof.event.html">tharsis.prof.event</a></li>
<li><a href="tharsis.prof.profiler.html">tharsis.prof.profiler</a></li>
<li><a href="tharsis.prof.ranges.html">tharsis.prof.ranges</a></li>
</ul>
</div>
</div>

<div id="content">
<h1>tharsis.prof.profiler</h1>
<!-- Generated by Ddoc from tharsis/prof/profiler.d -->
<p>Functionality needed to record profiling data.
</p>
<p>Profiler keeps track of profiling events.
<br>

 Zone is an RAII struct that records precise time at its construction and destruction.

</p>
<p><b>Realtime:</b><br>
Recording is very lightweight, without any complicated logic or heap allocations.
 This allows to use Tharsis-prof as a 'short-term profiler' that can record profiling
 data over the duration of a few frames and be detect bottlenecks in real time. Game
 code can then react, for example by disabling resource intensive nonessential features
 (e.g. particle systems).

</p>
<p><b>Precision:</b><br>
Tharsis.prof measures time in D 'hectonanoseconds', or tenths of a microsecond. This is
 precise enough to detect irregular overhead during frames but not to profile individual
 instructions in a linear algebra function. Such use cases are better covered by
 a Callgrind or a sampling profiler such as perf or CodeAnalyst. Also note that some
 platforms may not provide access to high-precision timers and the results may be even
 less precise. At least Linux, Windows and OSX should be alright, though.</p>

<dl><dt class="d_decl"><a name="Zone"></a>struct <a name="Zone"></a><span class="ddoc_psymbol">Zone</span>;
</dt>
<dd><p>Zone of profiled code.
</p>
<p>Emits a zone start event (recording start time) at construction and a zone end event
 (recording end time) at destruction.

</p>
<b>Examples:</b><div class="pbr"><pre class="d_code"><span class="d_comment">// Zones can be nested:
</span><span class="d_keyword">while</span>(!done)
{
    <span class="d_keyword">auto</span> frameZone = <span class="d_psymbol">Zone</span>(profiler, <span class="d_string">"frame"</span>);
    {
        <span class="d_keyword">auto</span> renderingZone = <span class="d_psymbol">Zone</span>(profiler, <span class="d_string">"rendering"</span>);

        <span class="d_comment">// do rendering here
</span>    }
    {
        <span class="d_keyword">auto</span> physicsZone = <span class="d_psymbol">Zone</span>(profiler, <span class="d_string">"physics"</span>);

        <span class="d_comment">// do physics here
</span>    }
}
</pre>
<br>

<pre class="d_code"><span class="d_comment">// A nested zone must be fully contained in its parent zone, e.g. this won't work:
</span><span class="d_keyword">auto</span> zone1 = <span class="d_psymbol">Zone</span>(profiler, <span class="d_string">"zone1"</span>);
<span class="d_keyword">while</span>(!done)
{
    <span class="d_keyword">auto</span> zone2 = <span class="d_psymbol">Zone</span>(profiler, <span class="d_string">"zone1"</span>);
    <span class="d_comment">// WRONG: zone1 destroyed manually before zone2
</span>    destroy(zone1);

    <span class="d_comment">// zone2 implicitly destroyed at the end of scope
</span>}
</pre>
</div>

<dl><dt class="d_decl"><a name="Zone.this"></a>nothrow @trusted this(Profiler <b>profiler</b>, string <b>info</b>);
</dt>
<dd><p>Construct a zone to record with specified profiler.
</p>
<p>Emits the zone start event.

</p>
<b>Parameters:</b><div class="pbr"><table class=parms><tr><td valign=top>Profiler <b>profiler</b></td>
<td valign=top>Profiler to record into. If <span class="d_inlinecode"><b>null</b></span>, the zone is ignored. This enables
            'optional profiling', where instrumenting code (zones) is always present
            in the code but only activated when a Profiler exists.</td></tr>
<tr><td valign=top>string <b>info</b></td>
<td valign=top>Zone information string. Used to recognize zones when parsing and
            accumulating profile data. Can be the 'name' of the zone, possibly with
            some extra info (e.g. "frame": entire frame or "batch 5": fifth draw
            batch). <b>Must not</b> be empty or longer than 255 characters and
            <b>must not</b> contain zero (<span class="d_inlinecode">'\0'</span>) characters.</td></tr>
</table></div>

</dd>
<dt class="d_decl"><a name="Zone.variableEvent"></a>pure nothrow @nogc @safe void <a name="variableEvent"></a><span class="ddoc_psymbol">variableEvent</span>(string name, V)(const V <b>value</b>);
</dt>
<dd><p>A shortcut to call <a name="variableEvent"></a><span class="ddoc_psymbol">variableEvent</span>() of the zone's profiler, if any.
</p>
<p>If a <b>null</b> Profiler has been passed to the Zone's constructor, this call is ignored.

</p>
<b>See Also:</b><div class="pbr">Profiler.<a name="variableEvent"></a><span class="ddoc_psymbol">variableEvent</span>().</div>

</dd>
</dl>
</dd>
<dt class="d_decl"><a name="Profiler"></a>class <a name="Profiler"></a><span class="ddoc_psymbol">Profiler</span>;
</dt>
<dd><p>Records profiling events into user-specified buffer.
</p>
<p>Used together with Zone to record data and with EventRange/ZoneRange/etc. for analysis.
<br>

 <a name="Profiler"></a><span class="ddoc_psymbol">Profiler</span> writes profiling data into a byte buffer passed to <a name="Profiler"></a><span class="ddoc_psymbol">Profiler</span> constructor by the
 user. Once there is not enough space to write any more profiling events, the profiler
 quietly ignores any events (this can be checked by outOfSpace()). <a name="Profiler"></a><span class="ddoc_psymbol">Profiler</span> <b>never
 allocates heap memory</b> by itself.
<br>

 Recorded data can be accessed at any time through profileData() and analyzed with help
 of EventRange, ZoneRange and other tharsis.prof utilities. reset() can be used to
 clear recorded data and start recording from scratch.

</p>
<p><b>Note:</b><br>
<a name="Profiler"></a><span class="ddoc_psymbol">Profiler</span> is <b>not</b> designed to be used from multiple threads. If you need to profile
 multiple threads, create a separate <a name="Profiler"></a><span class="ddoc_psymbol">Profiler</span> for each thread and either analyze the
 results through separate EventRange/ZoneRange instances, or merge them through
 accumulatedZoneRange.

</p>
<p><b>Note:</b><br>
Accessing profile data from an out-of-space profiler or in the middle of a zone will
 result in an EventRange that's missing some zone end events. Incomplete raw profiling
 results or EventRanges should never be concatenated. ZoneRange will automatically end
 the unfinished zones.
<br>

 Memory consumption:
<br>

 Depending on the worload and number of zones, <a name="Profiler"></a><span class="ddoc_psymbol">Profiler</span> can eat through assigned memory
 rather quickly.  With 10000 zones at 120 FPS the overhead is going to be around 14 MiB
 <b>per second</b>.</p>
<b>Examples:</b><div class="pbr"><pre class="d_code">
<span class="d_keyword">ubyte</span>[] storage = <span class="d_keyword">new</span> <span class="d_keyword">ubyte</span>[<span class="d_psymbol">Profiler</span>.maxEventBytes + 2048];
<span class="d_keyword">auto</span> profiler = <span class="d_keyword">new</span> <span class="d_psymbol">Profiler</span>(storage);

<span class="d_comment">// Simulate 16 'frames'
</span><span class="d_keyword">foreach</span>(frame; 0 .. 16)
{
    Zone topLevel = Zone(profiler, <span class="d_string">"frame"</span>);
    <span class="d_comment">// Record a variable event (useful for tracking FPS, entity count, network
</span>    <span class="d_comment">// traffic, etc.). Only uint, int and float supported at the moment.
</span>    profiler.variableEvent!<span class="d_string">"frame"</span> = <span class="d_keyword">cast</span>(<span class="d_keyword">uint</span>)frame;

    <span class="d_comment">// Simulate frame overhead. Replace this with your frame code.
</span>    {
        Zone nested1 = Zone(profiler, <span class="d_string">"frameStart"</span>);
        <span class="d_keyword">foreach</span>(i; 0 .. 1000) { <span class="d_keyword">continue</span>; }
    }
    {
        Zone nested2 = Zone(profiler, <span class="d_string">"frameCore"</span>);
        <span class="d_keyword">foreach</span>(i; 0 .. 10000) { <span class="d_keyword">continue</span>; }
    }
}

<span class="d_comment">// see tharsis.profiler.ranges for how to process recorded data
</span></pre>
</div><b>Examples:</b><div class="pbr"><pre class="d_code">
<span class="d_comment">// This example uses C malloc/free and std.typecons.scoped to show how to use Profiler
</span><span class="d_comment">// without GC allocations.
</span>
<span class="d_keyword">const</span> storageLength = <span class="d_psymbol">Profiler</span>.maxEventBytes + 2048;

<span class="d_keyword">import</span> core.stdc.stdlib;
<span class="d_comment">// A simple typed-slice malloc wrapper function would avoid the ugly cast/slicing.
</span><span class="d_keyword">ubyte</span>[] storage  = (<span class="d_keyword">cast</span>(<span class="d_keyword">ubyte</span>*)malloc(storageLength))[0 .. storageLength];
<span class="d_keyword">scope</span>(exit) { free(storage.ptr); }

<span class="d_keyword">import</span> std.typecons;
<span class="d_keyword">auto</span> profiler = scoped!<span class="d_psymbol">Profiler</span>(storage);

<span class="d_comment">// std.typecons.scoped! stores the Profiler on the stack.
</span><span class="d_comment">// Simulate 16 'frames'
</span><span class="d_keyword">foreach</span>(frame; 0 .. 16)
{
    Zone topLevel = Zone(profiler, <span class="d_string">"frame"</span>);

    <span class="d_comment">// Simulate frame overhead. Replace this with your frame code.
</span>    {
        Zone nested1 = Zone(profiler, <span class="d_string">"frameStart"</span>);
        <span class="d_keyword">foreach</span>(i; 0 .. 1000) { <span class="d_keyword">continue</span>; }
    }
    {
        Zone nested2 = Zone(profiler, <span class="d_string">"frameCore"</span>);
        <span class="d_keyword">foreach</span>(i; 0 .. 10000) { <span class="d_keyword">continue</span>; }
    }
}

<span class="d_comment">// see tharsis.profiler.ranges for how to process recorded data
</span></pre>
</div>
<dl><dt class="d_decl"><a name="Profiler.Diagnostics"></a>struct <a name="Diagnostics"></a><span class="ddoc_psymbol">Diagnostics</span>;
</dt>
<dd><p><a name="Diagnostics"></a><span class="ddoc_psymbol">Diagnostics</span> used to profile the profiler.</p>

</dd>
<dt class="d_decl"><a name="Profiler.maxEventBytes"></a>int <a name="maxEventBytes"></a><span class="ddoc_psymbol">maxEventBytes</span>;
</dt>
<dd><p>Maximum size of any single event in bytes. Used to quickly check if we're out of space.</p>

</dd>
<dt class="d_decl"><a name="Profiler.this"></a>nothrow @safe this(ubyte[] <b>profileBuffer</b>);
</dt>
<dd><p>Construct a Profiler writing profiling data to specified buffer.
</p>
<p>Profiler doesn't allocate heap memory. It will write profiling data into given
 buffer until it runs out of space, at which point it will silently stop profiling
 (this can be detected by outOfSpace() ).

</p>
<b>Parameters:</b><div class="pbr"><table class=parms><tr><td valign=top>ubyte[] <b>profileBuffer</b></td>
<td valign=top>Buffer to write profile data to. Must be at least
 Profiler.maxEventBytes long.</td></tr>
</table></div>

</dd>
<dt class="d_decl"><a name="Profiler.outOfSpace"></a>const pure nothrow @nogc @safe bool <a name="outOfSpace"></a><span class="ddoc_psymbol">outOfSpace</span>();
</dt>
<dd><p>Is the profiler out of space?
</p>
<p>When the profiler uses up all memory passed to the constructor, it quietly stops
 profiling. This can be used to determine if that has happened.</p>

</dd>
<dt class="d_decl"><a name="Profiler.diagnostics"></a>const pure nothrow @nogc @safe Diagnostics <a name="diagnostics"></a><span class="ddoc_psymbol">diagnostics</span>();
</dt>
<dd><p>Get <a name="diagnostics"></a><span class="ddoc_psymbol">diagnostics</span> about the profiler, such as which events are the most common.
</p>
<p>Useful for profiling the profiler.</p>

</dd>
<dt class="d_decl"><a name="Profiler.checkpointEvent"></a>pure nothrow @nogc @safe void <a name="checkpointEvent"></a><span class="ddoc_psymbol">checkpointEvent</span>();
</dt>
<dd><p>Emit a checkpoint event.
</p>
<p>A checkpoint event inserts the absolute time of the last event before the
 checkpoint. This allows reconstrucing event times from the checkpoint instead of
 from the start. It also inserts a zero byte into profiling data, which no other
 event can do. This allows to rewind profiler data without having to go all the way
 to the start.

</p>
<p><b>Note:</b><br>
neither of these options is actually exploited at the moment; but they should
       be useful for profiling visualizers and when processing massive profiling
       outputs.</p>

</dd>
<dt class="d_decl"><a name="Profiler.variableEvent"></a>pure nothrow @nogc @trusted void <a name="variableEvent"></a><span class="ddoc_psymbol">variableEvent</span>(string name, V)(const V <b>value</b>);
</dt>
<dd><p>Emit a variable event.
</p>
<p>Used to keep track of various variables that change over time, e.g. FPS, network
 traffic, entity count...; Despiker supports viewing the value of a variable once
 per frame.

</p>
<b>Parameters:</b><div class="pbr"><table class=parms><tr><td valign=top>name</td>
<td valign=top>Variable name (specified at compile-time). The variable event itself does
         not contain the name; the name is stored in an info event immediately
         after the variable event.</td></tr>
<tr><td valign=top>V</td>
<td valign=top>Variable type. Only int, uint and float are supported at the moment.</td></tr>
<tr><td valign=top>V value</td>
<td valign=top>Value of the variable</td></tr>
</table></div>
<p><b>Example:</b><br>
<pre class="d_code"><span class="d_comment">// Profiler profiler
</span>profiler.<span class="d_psymbol">variableEvent</span>!<span class="d_string">"FPS"</span>(4.5f);
</pre>
</p>

</dd>
<dt class="d_decl"><a name="Profiler.zoneStartEvent"></a>nothrow @system uint <a name="zoneStartEvent"></a><span class="ddoc_psymbol">zoneStartEvent</span>(const string <b>info</b>);
</dt>
<dd><p>Emit a zone start event, when code enters a zone.
</p>
<b>Parameters:</b><div class="pbr"><table class=parms><tr><td valign=top>string <b>info</b></td>
<td valign=top>Information about the zone (e.g. its name). Will be added as an <b>info</b> event
        following the zone start event. <b>Must not</b> be empty or longer than 255
        characters and <b>must not</b> contain zero (<span class="d_inlinecode">'\0'</span>) characters.</td></tr>
</table></div>
<b>Returns:</b><div class="pbr">Nesting level of the newly started zone. Must be passed when corresponding
          zoneEndEvent() is called. Used to ensure child events end before their
          parent events.

</div>
<p><b>Note:</b><br>
<a name="zoneStartEvent"></a><span class="ddoc_psymbol">zoneStartEvent</span> should only be aleed directly where the Zone struct is not
       sufficient (i.e. where a zone cannot be wrapped in a scope).</p>

</dd>
<dt class="d_decl"><a name="Profiler.zoneEndEvent"></a>nothrow @system void <a name="zoneEndEvent"></a><span class="ddoc_psymbol">zoneEndEvent</span>(const uint <b>nestLevel</b>);
</dt>
<dd><p>Emit a zone end event, when code exits a zone.
</p>
<b>Parameters:</b><div class="pbr"><table class=parms><tr><td valign=top>uint <b>nestLevel</b></td>
<td valign=top>Nesting level of the zone. Used to check that zones are exited in the
             correct (hierarchical) order, i.e. a child zone must be ended before
             its parent zone.</td></tr>
</table></div>
<p><b>Note:</b><br>
<a name="zoneEndEvent"></a><span class="ddoc_psymbol">zoneEndEvent</span> should only be called directly where the Zone struct is not
       sufficient (i.e. where a zone cannot be wrapped in a scope).</p>

</dd>
<dt class="d_decl"><a name="Profiler.reset"></a>nothrow @safe void <a name="reset"></a><span class="ddoc_psymbol">reset</span>();
</dt>
<dd><p>Reset the profiler.
</p>
<p>Clears all profiled data. Reuses the buffer passed by the constructor to start
 profiling from scratch.
<br>

 Can only be called outside of any Zone.</p>

</dd>
<dt class="d_decl"><a name="Profiler.profileData"></a>const pure nothrow @nogc @safe const(ubyte)[] <a name="profileData"></a><span class="ddoc_psymbol">profileData</span>();
</dt>
<dd><p>Get the raw data recorded by the profiler.
</p>
<p>This is a slice to the buffer passed to Profiler's constructor.</p>

</dd>
<dt class="d_decl"><a name="Profiler.zoneNestLevel"></a>const pure nothrow @nogc @safe uint <a name="zoneNestLevel"></a><span class="ddoc_psymbol">zoneNestLevel</span>();
</dt>
<dd><p>Get the nest level of the current zone, if any.
</p>
<p>0 means the profiler is not in any zone.</p>

</dd>
</dl>
</dd>
</dl>

</div>

<div id="copyright">
Copyright &copy; Ferdinand Majerech 2014 |
Page generated by AutoDDoc and <a href="http://www.digitalmars.com/d/2.0/ddoc.html">Ddoc</a>.
</div>

</body>
</html>

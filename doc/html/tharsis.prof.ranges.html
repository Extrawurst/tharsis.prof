<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN"
        "http://www.w3.org/TR/html4/strict.dtd">

<html lang='en'>
<head>
<meta http-equiv="content-type" content="text/html; charset=utf-8" >
<title>tharsis.prof.ranges - Tharsis.prof 0.1 API documentation</title>
<link rel="stylesheet" type="text/css" href="css/style.css">
</head>

<body><div id="top">
<div id="header">
<a id="main-heading" href="index.html">Tharsis.prof 0.1 API documentation</a>
</div>
</div>

<div id="navigation">
<div class="navblock">
<div id="toctop">
<ul><li><a href="http://code.dlang.org">More D libraries</a></li>
</ul>
</div>
</div>
<div class="navblock">
<ul><li><a href="index.html">Main page</a></li>
<li><a href="tharsis.prof.profiler.html">tharsis.prof.profiler</a></li>
<li><a href="tharsis.prof.ranges.html">tharsis.prof.ranges</a></li>
</ul>
</div>
</div>

<div id="content">
<h1>tharsis.prof.ranges</h1>
<!-- Generated by Ddoc from tharsis/prof/ranges.d -->
<p>Ranges used to process and analyze profiling results.
</p>
<p>Code examples can be found below.</p>

<dl><dt class="d_decl"><a name="Event"></a>struct <a name="Event"></a><span class="ddoc_psymbol">Event</span>;
</dt>
<dd><p>Profiling event generated by EventRange.</p>

<dl><dt class="d_decl"><a name="Event.id"></a>EventID <a name="id"></a><span class="ddoc_psymbol">id</span>;
</dt>
<dd><p>Event ID or type.</p>

</dd>
<dt class="d_decl"><a name="Event.startTime"></a>ulong <a name="startTime"></a><span class="ddoc_psymbol">startTime</span>;
</dt>
<dd><p>Start time of the event since recording started in hectonanoseconds.</p>

</dd>
<dt class="d_decl"><a name="Event.info"></a>const(char)[] <a name="info"></a><span class="ddoc_psymbol">info</span>;
</dt>
<dd><p>Information string if id == <span class="d_inlinecode">EventID.Info</span> .</p>

</dd>
</dl>
</dd>
<dt class="d_decl"><a name="ZoneData"></a>struct <a name="ZoneData"></a><span class="ddoc_psymbol">ZoneData</span>;
</dt>
<dd><p>Data about a zone generated by ZoneRange.</p>

<dl><dt class="d_decl"><a name="ZoneData.id"></a>uint <a name="id"></a><span class="ddoc_psymbol">id</span>;
</dt>
<dd><p>ID of this zone.</p>

</dd>
<dt class="d_decl"><a name="ZoneData.parentID"></a>uint <a name="parentID"></a><span class="ddoc_psymbol">parentID</span>;
</dt>
<dd><p>ID of the parent zone. 0 if the zone has no parent.</p>

</dd>
<dt class="d_decl"><a name="ZoneData.nestLevel"></a>ushort <a name="nestLevel"></a><span class="ddoc_psymbol">nestLevel</span>;
</dt>
<dd><p>Nesting level of the zone. 1 is top-level, 2 children of top-level, etc. 0 is invalid.</p>

</dd>
<dt class="d_decl"><a name="ZoneData.startTime"></a>ulong <a name="startTime"></a><span class="ddoc_psymbol">startTime</span>;
</dt>
<dd><p>Start time of the zone since recording started in hectonanoseconds.</p>

</dd>
<dt class="d_decl"><a name="ZoneData.duration"></a>ulong <a name="duration"></a><span class="ddoc_psymbol">duration</span>;
</dt>
<dd><p>Duration of the zone in hectonanoseconds.</p>

</dd>
<dt class="d_decl"><a name="ZoneData.info"></a>const(char)[] <a name="info"></a><span class="ddoc_psymbol">info</span>;
</dt>
<dd><p>Zone info (passed to the Zone constructor); e.g. it's name.</p>

</dd>
<dt class="d_decl"><a name="ZoneData.endTime"></a>const pure nothrow @nogc @safe ulong <a name="endTime"></a><span class="ddoc_psymbol">endTime</span>();
</dt>
<dd><p>Get the end time of the zone since recording started in hectonanoseconds.</p>

</dd>
</dl>
</dd>
<dt class="d_decl"><a name="AccumulatedZoneData"></a>struct <a name="AccumulatedZoneData"></a><span class="ddoc_psymbol">AccumulatedZoneData</span>(alias accumulate);
</dt>
<dd><p>Data accumulated from multiple matching zones, generated by <span class="d_inlinecode">  accumulatedZoneRange()</span>.
</p>
<p>Extends <span class="d_inlinecode">ZoneData</span> (derived using alias this) with a value returned by the <span class="d_inlinecode"> accumulate</span> function parameter of <span class="d_inlinecode">accumulatedZoneRange()</span>.
<br>

 Durations and start times of accumulated zones are summed into <span class="d_inlinecode">zoneData.duration</span>
 and <span class="d_inlinecode">zoneData.startTime</span>. <span class="d_inlinecode">id</span>, <span class="d_inlinecode">parentID</span> and <span class="d_inlinecode">nestLevel</span> are updated so
 the elements of <span class="d_inlinecode">accumulatedZoneRange</span> can still form trees just like elements of
 the <span class="d_inlinecode">ZoneRange</span> that was accumulated.</p>

<dl><dt class="d_decl"><a name="AccumulatedZoneData.zoneData"></a>ZoneData <a name="zoneData"></a><span class="ddoc_psymbol">zoneData</span>;
</dt>
<dd><p>The 'base' ZoneData; startTime and duration are sums of accumulated ZoneData values.</p>

</dd>
<dt class="d_decl"><a name="AccumulatedZoneData.accumulated"></a>ReturnType!accumulate <a name="accumulated"></a><span class="ddoc_psymbol">accumulated</span>;
</dt>
<dd><p>The value <a name="accumulated"></a><span class="ddoc_psymbol">accumulated</span> by the accumulate function.</p>

</dd>
</dl>
</dd>
<dt class="d_decl"><a name="defaultMatch"></a>pure nothrow @nogc @safe bool <a name="defaultMatch"></a><span class="ddoc_psymbol">defaultMatch</span>(const(char)[] <b>info1</b>, const(char)[] <b>info2</b>);
</dt>
<dd><p>Default match function for accumulatedZoneRange(). Compares ZoneData infos for equality.</p>

</dd>
<dt class="d_decl"><a name="accumulatedZoneRange"></a>pure nothrow @nogc @trusted auto <a name="accumulatedZoneRange"></a><span class="ddoc_psymbol">accumulatedZoneRange</span>(alias accumulate, alias match = defaultMatch, ZRange)(AccumulatedZoneData!accumulate[] <b>storage</b>, ZRange[] <b>zones</b>...);
</dt>
<dd><p>Returns a range that accumulates (merges) matching zones from one or more zone ranges.
</p>
<p>On each nesting level from top to bottom, finds zones that are <b>match</b> based on
 given match function and merges them into one zone, <b>accumulating</b> data from merged
 zone using the accumulate function. Merged zones contain summed durations and start
 times. The default match function compares info strings of two zones for equality.
<br>

<br>

 This is useful for example to get a 'total' of all frames elapsed while the profiler
 was running. If each frame has one top-level zone and they have matching info strings,
 the top-level zones will be merged, then all zones within those top-level zones, and so
 on. The result will be a zone range representing a single tree. The accumulate function
 could be used, for example, to calculate the maximum duration of matching zones to
 calculate a 'worst case frame scenario', or to calculate the number of times each zone
 was entered, or even multiple things at the same time.

</p>
<b>Parameters:</b><div class="pbr"><table class=parms><tr><td valign=top>accumulate</td>
<td valign=top>A function alias that takes a pointer to the value accumulated so far, and
              the next ZoneData to accumulate. It returns the resulting accumulated
              value. The first parameter will be <b>null</b> on the first call.
<br>

              Must be <span class="d_inlinecode">pure nothrow @nogc</span>.</td></tr>
<tr><td valign=top>match</td>
<td valign=top>A function alias that takes two const(char) arrays and returns a bool.
              If <b>true</b> is returned, two zones with whose info strings were passed to
              match() are considered the same zone and will be merged and accumulated.
<br>

              Must be <span class="d_inlinecode">pure nothrow @nogc</span>.
<br>

              An example use-case for a custom match() function is to accumulate related
              zones that have a slightly different names (e.g. numbered draw batches),
              or on the other hand, to prevent merging zones with identical names
              (e.g. to see each individual draw as a separate zone).</td></tr>
<tr><td valign=top>AccumulatedZoneData!accumulate[] storage</td>
<td valign=top>Array to use for temporary storage during accumulation <b>as well as</b>
              storage in the returned range. Must be long enough to hold zones from all
              passed zone ranges, i.e. the sum of their walkLengths. To determine this
              length, use <span class="d_inlinecode">import std.range; zoneRange.walkLength;</span>.</td></tr>
<tr><td valign=top>ZRange[] zones</td>
<td valign=top>One or more zone ranges to accumulate.</td></tr>
</table></div>
<b>Returns:</b><div class="pbr">A ForwardRange of AccumulatedZoneData. Each element contails ZoneData plus the
          return value of the accumulate function.

</div>
<p><b>Note:</b><br>
 The current implementation is likely to be slow for large inputs. It's probably
       too slow for real-time usage except if the inputs are very small.
<br>

 Example of an <span class="d_inlinecode">accumulate</span> function:
<pre class="d_code"><span class="d_comment">// Increments the accumulated value when called. Useful to determine the
</span><span class="d_comment">// number of times a Zone was entered.
</span>size_t accum(size_t* aPtr, <span class="d_keyword">ref</span> <span class="d_keyword">const</span> ZoneData z) <span class="d_keyword">pure</span> <span class="d_keyword">nothrow</span> @nogc
{
    <span class="d_keyword">return</span> aPtr <span class="d_keyword">is</span> <span class="d_keyword">null</span> ? 1 : *aPtr + 1;
}
</pre>
</p>
<b>Examples:</b><div class="pbr"><pre class="d_code">
<span class="d_comment">// Count the number of times each zone was entered.
</span><span class="d_keyword">auto</span> storage  = <span class="d_keyword">new</span> <span class="d_keyword">ubyte</span>[Profiler.maxEventBytes + 128];
<span class="d_keyword">auto</span> profiler = <span class="d_keyword">new</span> Profiler(storage);

<span class="d_keyword">foreach</span>(i; 0 .. 3)
{
    <span class="d_keyword">import</span> std.datetime;
    <span class="d_keyword">auto</span> startTime = Clock.currStdTime();
    profiler.frameEvent();
    <span class="d_comment">// Wait long enough to trigger a long time span event
</span>    <span class="d_keyword">while</span>(Clock.currStdTime() - startTime &lt;= Profiler.longTimeSpan) { <span class="d_keyword">continue</span>; }
    <span class="d_keyword">auto</span> zone1 = Zone(profiler, <span class="d_string">"zone1"</span>);
    {
        <span class="d_keyword">auto</span> zone11 = Zone(profiler, <span class="d_string">"zone11"</span>);
    }
    startTime = Clock.currStdTime();
    <span class="d_comment">// Wait long enough to trigger a short time span event
</span>    <span class="d_keyword">while</span>(Clock.currStdTime() - startTime &lt;= Profiler.timeSpan) { <span class="d_keyword">continue</span>; }
    {
        <span class="d_keyword">auto</span> zone12 = Zone(profiler, <span class="d_string">"zone12"</span>);
    }
}


<span class="d_comment">// Count the number of instances of each zone.
</span>size_t accum(size_t* aPtr, <span class="d_keyword">ref</span> <span class="d_keyword">const</span> ZoneData z) <span class="d_keyword">pure</span> <span class="d_keyword">nothrow</span> @nogc
{
    <span class="d_keyword">return</span> aPtr <span class="d_keyword">is</span> <span class="d_keyword">null</span> ? 1 : *aPtr + 1;
}

<span class="d_keyword">auto</span> zones        = profiler.profileData.zoneRange;
<span class="d_keyword">auto</span> accumStorage = <span class="d_keyword">new</span> AccumulatedZoneData!accum[zones.walkLength];
<span class="d_keyword">auto</span> accumulated  = <span class="d_psymbol">accumulatedZoneRange</span>!accum(accumStorage, zones.save);

<span class="d_keyword">assert</span>(accumulated.walkLength == 3);

<span class="d_keyword">import</span> std.stdio;
<span class="d_keyword">foreach</span>(zone; accumulated)
{
    writeln(zone);
}
</pre>
</div><b>Examples:</b><div class="pbr"><pre class="d_code">
<span class="d_comment">// Accumulate minimum, maximum, average duration and more simultaneously.
</span>
<span class="d_comment">// This example also uses C malloc/free, std.typecons.scoped and std.container.Array
</span><span class="d_comment">// to show how to do this without using the GC.
</span>
<span class="d_keyword">const</span> storageLength = Profiler.maxEventBytes + 2048;

<span class="d_keyword">import</span> core.stdc.stdlib;
<span class="d_comment">// A simple typed-slice malloc wrapper function would avoid the ugly cast/slicing.
</span><span class="d_keyword">ubyte</span>[] storage  = (<span class="d_keyword">cast</span>(<span class="d_keyword">ubyte</span>*)malloc(storageLength))[0 .. storageLength];
<span class="d_keyword">scope</span>(exit) { free(storage.ptr); }

<span class="d_keyword">import</span> std.typecons;
<span class="d_comment">// std.typecons.scoped! stores the Profiler on the stack.
</span><span class="d_keyword">auto</span> profiler = scoped!Profiler(storage);

<span class="d_comment">// Simulate 16 'frames'
</span><span class="d_keyword">foreach</span>(frame; 0 .. 16)
{
    Zone topLevel = Zone(profiler, <span class="d_string">"frame"</span>);

    <span class="d_comment">// Simulate frame overhead. Replace this with your frame code.
</span>    {
        Zone nested1 = Zone(profiler, <span class="d_string">"frameStart"</span>);
        <span class="d_keyword">foreach</span>(i; 0 .. 1000) { <span class="d_keyword">continue</span>; }
    }
    {
        Zone nested2 = Zone(profiler, <span class="d_string">"frameCore"</span>);
        <span class="d_keyword">foreach</span>(i; 0 .. 10000) { <span class="d_keyword">continue</span>; }
    }
}

<span class="d_comment">// Accumulate data into this struct.
</span><span class="d_keyword">struct</span> ZoneInfo
{
    <span class="d_keyword">ulong</span> minDuration;
    <span class="d_keyword">ulong</span> maxDuration;
    <span class="d_comment">// Needed to calculate average duration.
</span>    size_t instanceCount;

    <span class="d_comment">// We also need the total duration to calculate average, but that is accumulated
</span>    <span class="d_comment">// by default in AccumulatedZoneData.
</span>}

<span class="d_comment">// Gets min, max, total duration as well as the number of times the zone was entered.
</span>ZoneInfo accum(ZoneInfo* aPtr, <span class="d_keyword">ref</span> <span class="d_keyword">const</span> ZoneData z) <span class="d_keyword">pure</span> <span class="d_keyword">nothrow</span> @nogc
{
    <span class="d_keyword">if</span>(aPtr <span class="d_keyword">is</span> <span class="d_keyword">null</span>) { <span class="d_keyword">return</span> ZoneInfo(z.duration, z.duration, 1); }

    <span class="d_keyword">return</span> ZoneInfo(min(aPtr.minDuration, z.duration),
                    max(aPtr.maxDuration, z.duration),
                    aPtr.instanceCount + 1);
}

<span class="d_keyword">auto</span> zones      = profiler.profileData.zoneRange;
<span class="d_comment">// Allocate storage to accumulate in with malloc.
</span><span class="d_keyword">const</span> zoneCount = zones.walkLength;
<span class="d_keyword">alias</span> Data = AccumulatedZoneData!accum;
<span class="d_keyword">auto</span> accumStorage = (<span class="d_keyword">cast</span>(Data*)malloc(zoneCount * Data.sizeof))[0 .. zoneCount];
<span class="d_keyword">scope</span>(exit) { free(accumStorage.ptr); }

<span class="d_keyword">auto</span> accumulated = <span class="d_psymbol">accumulatedZoneRange</span>!accum(accumStorage, zones.save);

<span class="d_comment">// Write out the results.
</span><span class="d_keyword">foreach</span>(zone; accumulated) <span class="d_keyword">with</span>(zone.accumulated)
{
    <span class="d_keyword">import</span> std.stdio;
    writefln(<span class="d_string">"id: %s, min: %s, max: %s, avg: %s, total: %s, count: %s"</span>,
             zone.id, minDuration, maxDuration,
             zone.duration / <span class="d_keyword">cast</span>(<span class="d_keyword">double</span>)instanceCount, zone.duration, instanceCount);
}
</pre>
</div><b>Examples:</b><div class="pbr"><pre class="d_code">
<span class="d_comment">// Get the average duration of a top-level zone. This is a good way to determine
</span><span class="d_comment">// average frame duration as the top-level zone often encapsulates a frame.
</span>
<span class="d_comment">// This example also uses C malloc/free, std.typecons.scoped and std.container.Array
</span><span class="d_comment">// to show how to do this without using the GC.
</span>
<span class="d_keyword">const</span> storageLength = Profiler.maxEventBytes + 2048;

<span class="d_keyword">import</span> core.stdc.stdlib;
<span class="d_comment">// A simple typed-slice malloc wrapper function would avoid the ugly cast/slicing.
</span><span class="d_keyword">ubyte</span>[] storage  = (<span class="d_keyword">cast</span>(<span class="d_keyword">ubyte</span>*)malloc(storageLength))[0 .. storageLength];
<span class="d_keyword">scope</span>(exit) { free(storage.ptr); }

<span class="d_keyword">import</span> std.typecons;
<span class="d_comment">// std.typecons.scoped! stores the Profiler on the stack.
</span><span class="d_keyword">auto</span> profiler = scoped!Profiler(storage);

<span class="d_comment">// Simulate 16 'frames'
</span><span class="d_keyword">foreach</span>(frame; 0 .. 16)
{
    Zone topLevel = Zone(profiler, <span class="d_string">"frame"</span>);

    <span class="d_comment">// Simulate frame overhead. Replace this with your frame code.
</span>    {
        Zone nested1 = Zone(profiler, <span class="d_string">"frameStart"</span>);
        <span class="d_keyword">foreach</span>(i; 0 .. 1000) { <span class="d_keyword">continue</span>; }
    }
    {
        Zone nested2 = Zone(profiler, <span class="d_string">"frameCore"</span>);
        <span class="d_keyword">foreach</span>(i; 0 .. 10000) { <span class="d_keyword">continue</span>; }
    }
}

<span class="d_comment">// Count the number of instances of each zone.
</span>size_t accum(size_t* aPtr, <span class="d_keyword">ref</span> <span class="d_keyword">const</span> ZoneData z) <span class="d_keyword">pure</span> <span class="d_keyword">nothrow</span> @nogc
{
    <span class="d_keyword">return</span> aPtr <span class="d_keyword">is</span> <span class="d_keyword">null</span> ? 1 : *aPtr + 1;
}

<span class="d_keyword">import</span> std.algorithm;
<span class="d_comment">// Top-level zones are level 1.
</span><span class="d_comment">//
</span><span class="d_comment">// Filtering zones before accumulating allows us to decrease memory space needed for
</span><span class="d_comment">// accumulation, as well as speed up the accumulation, which is relatively expensive.
</span><span class="d_keyword">auto</span> zones = profiler.profileData.zoneRange.filter!(z =&gt; z.nestLevel == 1);
<span class="d_comment">// Allocate storage to accumulate in with malloc.
</span><span class="d_keyword">const</span> zoneCount = zones.walkLength;
<span class="d_keyword">alias</span> Data = AccumulatedZoneData!accum;
<span class="d_keyword">auto</span> accumStorage = (<span class="d_keyword">cast</span>(Data*)malloc(zoneCount * Data.sizeof))[0 .. zoneCount];
<span class="d_keyword">scope</span>(exit) { free(accumStorage.ptr); }

<span class="d_keyword">auto</span> accumulated = <span class="d_psymbol">accumulatedZoneRange</span>!accum(accumStorage, zones.save);

<span class="d_comment">// If there is just one top-level zone, and it always has the same info ("frame" in
</span><span class="d_comment">// this case), accumulatedZoneRange with the default match function will have exactly
</span><span class="d_comment">// 1 element; with the accumulated result for all instances of the zone. Also here,
</span><span class="d_comment">// we use $(D duration), which is accumulated by default.
</span><span class="d_keyword">import</span> std.stdio;
writeln(accumulated.front.duration / <span class="d_keyword">cast</span>(<span class="d_keyword">real</span>)accumulated.front.accumulated);
</pre>
</div>
</dd>
<dt class="d_decl"><a name="zoneRange"></a>pure nothrow @nogc @safe ZoneRange!EventRange <a name="zoneRange"></a><span class="ddoc_psymbol">zoneRange</span>(const(ubyte)[] <b>profileData</b>);
</dt>
<dd><p>Construct a ZoneRange directly from profile data.
</p>
<b>Parameters:</b><div class="pbr"><table class=parms><tr><td valign=top>const(ubyte)[] <b>profileData</b></td>
<td valign=top>Profile data recorded by a Profiler. Note that modifying or concatenating
               raw profile data is unsafe unless you know what you're doing.</td></tr>
</table></div>
<p><b>Example:</b><br>
<pre class="d_code"><span class="d_comment">// Profiler profiler;
</span>
<span class="d_comment">// Create a ZoneRange from profile data with UFCS syntax.
</span><span class="d_keyword">auto</span> zones = profiler.<span class="d_param">profileData</span>.<span class="d_psymbol">zoneRange</span>;
<span class="d_keyword">foreach</span>(zone; zones)
{
    <span class="d_keyword">import</span> std.stdio;
    writeln(event);
}
</pre>
</p>

</dd>
<dt class="d_decl"><a name="ZoneRange"></a>struct <a name="ZoneRange"></a><span class="ddoc_psymbol">ZoneRange</span>(ERange);
</dt>
<dd><p>Light-weight range that iterates over zones in profile data.
</p>
<p>Constructed from a ForwardRange of Event (e.g. EventRange or a std.algorithm/std.range
 wrapper around an EventRange). Can also be constructed from raw profile data using
 eventRange().
<br>

<br>

 ForwardRange of ZoneData ordered by <i>end time</i>.
 Doesn't allocate any memory.
<br>

<br>

 If profile data is incomplete (e.g. because the Profiler ran out of assigned memory in
 the middle of profiling), zones that don't have zone end events will be automatically
 ended at the time of the last recorded event.

</p>
<p><b>Note:</b><br>
<a name="ZoneRange"></a><span class="ddoc_psymbol">ZoneRange</span> only supports zone nesting up to <a name="ZoneRange"></a><span class="ddoc_psymbol">ZoneRange</span>.zoneStack nesting levels
 (currently this is 640, which should be enough for everyone, may be increased in future).</p>
<b>Examples:</b><div class="pbr"><pre class="d_code">
<span class="d_comment">// Filter zones based on the info string. Useful to determine durations of only
</span><span class="d_comment">// certain zones.
</span>
<span class="d_keyword">auto</span> storage  = <span class="d_keyword">new</span> <span class="d_keyword">ubyte</span>[Profiler.maxEventBytes + 2048];
<span class="d_keyword">auto</span> profiler = <span class="d_keyword">new</span> Profiler(storage);

<span class="d_comment">// Simulate 16 'frames'
</span><span class="d_keyword">foreach</span>(frame; 0 .. 16)
{
    Zone topLevel = Zone(profiler, <span class="d_string">"frame"</span>);

    <span class="d_comment">// Simulate frame overhead. Replace this with your frame code.
</span>    {
        Zone nested1 = Zone(profiler, <span class="d_string">"frameStart"</span>);
        <span class="d_keyword">foreach</span>(i; 0 .. 1000) { <span class="d_keyword">continue</span>; }
    }
    {
        Zone nested2 = Zone(profiler, <span class="d_string">"frameCore"</span>);
        <span class="d_keyword">foreach</span>(i; 0 .. 10000) { <span class="d_keyword">continue</span>; }
    }
}

<span class="d_keyword">import</span> std.algorithm;
<span class="d_comment">// Write duration of each instance of the "frameCore" zone.
</span><span class="d_keyword">foreach</span>(zone; profiler.profileData.zoneRange.filter!(z =&gt; z.info == <span class="d_string">"frameCore"</span>))
{
    <span class="d_keyword">import</span> std.stdio;
    writeln(zone.duration);
}
</pre>
</div><b>Examples:</b><div class="pbr"><pre class="d_code">
<span class="d_comment">// Sort top-level zones by duration. If there is one top-level zone per frame, this
</span><span class="d_comment">// sorts frames by duration: useful to get the worst-case frames.
</span>
<span class="d_comment">// This example also uses C malloc/free, std.typecons.scoped and std.container.Array
</span><span class="d_comment">// to show how to do this without using the GC.
</span>
<span class="d_keyword">const</span> storageLength = Profiler.maxEventBytes + 1024 * 1024 * 2;

<span class="d_keyword">import</span> core.stdc.stdlib;
<span class="d_comment">// A simple typed-slice malloc wrapper function would avoid the ugly cast/slicing.
</span><span class="d_keyword">ubyte</span>[] storage  = (<span class="d_keyword">cast</span>(<span class="d_keyword">ubyte</span>*)malloc(storageLength))[0 .. storageLength];
<span class="d_keyword">scope</span>(exit) { free(storage.ptr); }

<span class="d_keyword">import</span> std.typecons;
<span class="d_keyword">auto</span> profiler = scoped!Profiler(storage);

<span class="d_comment">// std.typecons.scoped! stores the Profiler on the stack.
</span><span class="d_comment">// Simulate 16 'frames'
</span><span class="d_keyword">foreach</span>(frame; 0 .. 16)
{
    Zone topLevel = Zone(profiler, <span class="d_string">"frame"</span>);

    <span class="d_comment">// Simulate frame overhead. Replace this with your frame code.
</span>    {
        Zone nested1 = Zone(profiler, <span class="d_string">"frameStart"</span>);
        <span class="d_keyword">foreach</span>(i; 0 .. 1000) { <span class="d_keyword">continue</span>; }
    }
    {
        Zone nested2 = Zone(profiler, <span class="d_string">"frameCore"</span>);
        <span class="d_keyword">foreach</span>(i; 0 .. 10000) { <span class="d_keyword">continue</span>; }
    }
}

<span class="d_keyword">import</span> std.algorithm;
<span class="d_keyword">auto</span> zones = profiler.profileData.zoneRange;

<span class="d_comment">// nestLevel of 1 is toplevel.
</span><span class="d_keyword">auto</span> topLevel = zones.filter!(z =&gt; z.nestLevel == 1);

<span class="d_keyword">import</span> std.container;
<span class="d_comment">// std.container.Array constructor builds an RAII array containing zones from topLevel.
</span><span class="d_comment">// We need an array as we need random access to sort the zones (ZoneRange generates
</span><span class="d_comment">// ZoneData on-the-fly as it processes profiling data, so it has no random access).
</span><span class="d_keyword">auto</span> topLevelArray = Array!ZoneData(topLevel);
topLevelArray[].sort!((a, b) =&gt; a.duration &gt; b.duration);

<span class="d_keyword">import</span> std.stdio;
<span class="d_comment">// Print the 4 longest frames.
</span><span class="d_keyword">foreach</span>(frame; topLevelArray[0 .. 4])
{
    writeln(frame);
}

<span class="d_keyword">auto</span> worst = topLevelArray[0];

<span class="d_comment">// Print details about all zones in the worst frame.
</span>writeln(<span class="d_string">"Zones in the worst frame:"</span>);
<span class="d_keyword">foreach</span>(zone; zones.filter!(z =&gt; z.startTime &gt;= worst.startTime &amp;&amp; z.endTime &lt;= worst.endTime))
{
    writefln(<span class="d_string">"%s: %s hnsecs from %s to %s"</span>,
             zone.info, zone.duration, zone.startTime, zone.endTime);
}
</pre>
</div>
<dl><dt class="d_decl"><a name="ZoneRange.this"></a>pure nothrow @nogc @safe this(ERange <b>events</b>);
</dt>
<dd><p>Construct a ZoneRange processing <b>events</b> from a range of Events (e.g. EventRange).
</p>
<b>Parameters:</b><div class="pbr"><table class=parms><tr><td valign=top>ERange <b>events</b></td>
<td valign=top>The event range to read from. ZoneRange will create a (shallow) copy,
          and will not consume this range.</td></tr>
</table></div>

</dd>
<dt class="d_decl"><a name="ZoneRange.front"></a>pure nothrow @nogc @safe ZoneData <a name="front"></a><span class="ddoc_psymbol">front</span>();
</dt>
<dd><p>Get the current zone.</p>

</dd>
<dt class="d_decl"><a name="ZoneRange.popFront"></a>pure nothrow @nogc @safe void <a name="popFront"></a><span class="ddoc_psymbol">popFront</span>();
</dt>
<dd><p>Go to the next zone.</p>

</dd>
<dt class="d_decl"><a name="ZoneRange.empty"></a>pure nothrow @nogc @safe bool <a name="empty"></a><span class="ddoc_psymbol">empty</span>();
</dt>
<dd><p>Are there no more zones?</p>

</dd>
<dt class="d_decl"><a name="ZoneRange.save"></a>const pure nothrow @nogc @property @safe ZoneRange <a name="save"></a><span class="ddoc_psymbol">save</span>();
</dt>
<dd><p>Get a copy of the range in its current state.</p>

</dd>
</dl>
</dd>
<dt class="d_decl"><a name="eventRange"></a>pure nothrow @nogc @safe EventRange <a name="eventRange"></a><span class="ddoc_psymbol">eventRange</span>(const(ubyte)[] <b>profileData</b>);
</dt>
<dd><p>Construct an EventRange directly from profile data.
</p>
<p>ForwardRange of Event.

</p>
<b>Parameters:</b><div class="pbr"><table class=parms><tr><td valign=top>const(ubyte)[] <b>profileData</b></td>
<td valign=top>Profile data recorded by a Profiler. Note that modifying or concatenating
               profile data is unsafe unless you know what you're doing.</td></tr>
</table></div>
<p><b>Example:</b><br>
<pre class="d_code"><span class="d_comment">// Profiler profiler;
</span>
<span class="d_comment">// Create an EventRange from profile data with UFCS syntax.
</span><span class="d_keyword">auto</span> events = profiler.<span class="d_param">profileData</span>.<span class="d_psymbol">eventRange</span>;
<span class="d_keyword">foreach</span>(event; events)
{
    <span class="d_keyword">import</span> std.stdio;
    writeln(event);
}
</pre>
</p>

</dd>
<dt class="d_decl"><a name="EventRange"></a>struct <a name="EventRange"></a><span class="ddoc_psymbol">EventRange</span>;
</dt>
<dd><p>Light-weight type-safe range that iterates over events in profile data.
</p>
<p><a name="EventRange"></a><span class="ddoc_psymbol">EventRange</span> is a 'low-level' range to base other ranges or structures (such as
 ZoneRange) on top of.
<br>

 Doesn't allocate any memory.</p>
<b>Examples:</b><div class="pbr"><pre class="d_code">
<span class="d_comment">// Filter zones based on the info string. Useful to determine durations of only
</span><span class="d_comment">// certain zones.
</span>
<span class="d_keyword">auto</span> storage  = <span class="d_keyword">new</span> <span class="d_keyword">ubyte</span>[Profiler.maxEventBytes + 2048];
<span class="d_keyword">auto</span> profiler = <span class="d_keyword">new</span> Profiler(storage);

<span class="d_comment">// Simulate 16 'frames'
</span><span class="d_keyword">foreach</span>(frame; 0 .. 16)
{
    Zone topLevel = Zone(profiler, <span class="d_string">"frame"</span>);

    <span class="d_comment">// Simulate frame overhead. Replace this with your frame code.
</span>    {
        Zone nested1 = Zone(profiler, <span class="d_string">"frameStart"</span>);
        <span class="d_keyword">foreach</span>(i; 0 .. 1000) { <span class="d_keyword">continue</span>; }
    }
    {
        Zone nested2 = Zone(profiler, <span class="d_string">"frameCore"</span>);
        <span class="d_keyword">foreach</span>(i; 0 .. 10000) { <span class="d_keyword">continue</span>; }
    }
}

<span class="d_keyword">import</span> std.stdio;
<span class="d_comment">// Create an EventRange from profile data with UFCS syntax.
</span><span class="d_keyword">auto</span> events = profiler.profileData.eventRange;
<span class="d_comment">// Foreach over range calls popFront()/front()/empty() internally
</span><span class="d_keyword">foreach</span>(event; events)
{
    writeln(event);
}

<span class="d_comment">// Get a range of only the events with start time between 1000 and 5000 (hectonanoseconds)
</span><span class="d_comment">//
</span><span class="d_comment">// This doesn't filter anything or allocate memory; filtering only happens once the
</span><span class="d_comment">// range is iterated over (but if we did want to do the filtering right now, e.g. to
</span><span class="d_comment">// get an array of filtered results, we'd suffix this with ".array")
</span><span class="d_keyword">auto</span> filtered = events.filter!(e =&gt; e.startTime &gt; 1500 &amp;&amp; e.startTime &lt; 2000);
<span class="d_comment">// Here, we print the IDs of events between 10000 and 50000 hectonanoseconds
</span><span class="d_keyword">foreach</span>(id; filtered.map!(e =&gt; e.id))
{
    writeln(id);
}

<span class="d_comment">// And here we count the number of events between 1000 and 5000
</span>writeln(filtered.count);
</pre>
</div>
<dl><dt class="d_decl"><a name="EventRange.this"></a>pure nothrow @nogc @safe this(const(ubyte)[] <b>profileData</b>);
</dt>
<dd><p>Construct an EventRange.
</p>
<b>Parameters:</b><div class="pbr"><table class=parms><tr><td valign=top>const(ubyte)[] <b>profileData</b></td>
<td valign=top>Profile data recorded by a Profiler. Note that modifying or
               concatenating raw profile data is unsafe unless you know what you're
               doing.</td></tr>
</table></div>

</dd>
<dt class="d_decl"><a name="EventRange.front"></a>const pure nothrow @nogc @safe Event <a name="front"></a><span class="ddoc_psymbol">front</span>();
</dt>
<dd><p>Get the current event.</p>

</dd>
<dt class="d_decl"><a name="EventRange.popFront"></a>pure nothrow @nogc @safe void <a name="popFront"></a><span class="ddoc_psymbol">popFront</span>();
</dt>
<dd><p>Move to the next event.</p>

</dd>
<dt class="d_decl"><a name="EventRange.empty"></a>const pure nothrow @nogc @safe bool <a name="empty"></a><span class="ddoc_psymbol">empty</span>();
</dt>
<dd><p>Are there no more events?</p>

</dd>
<dt class="d_decl"><a name="EventRange.save"></a>const pure nothrow @nogc @property @safe EventRange <a name="save"></a><span class="ddoc_psymbol">save</span>();
</dt>
<dd><p>Get a copy of the range in its current state.</p>

</dd>
</dl>
</dd>
</dl>

</div>

<div id="copyright">
Copyright &copy; Ferdinand Majerech 2014 |
Page generated by AutoDDoc and <a href="http://www.digitalmars.com/d/2.0/ddoc.html">Ddoc</a>.
</div>

</body>
</html>
